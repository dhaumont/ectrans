MODULE TPM_FFTR

!   Author.
!   -------
!     George Mozdzynski
!
!   Modifications.
!   -------------- 
!     Original      October 2014

USE, INTRINSIC :: ISO_C_BINDING

USE PARKIND_ECTRANS, ONLY: JPIB, JPIM, JPRBT
USE MPL_MODULE, ONLY : MPL_MYRANK

IMPLICIT NONE

SAVE

PRIVATE
PUBLIC CREATE_PLAN_FFTR, DESTROY_PLAN_FFTR, DESTROY_ALL_PLANS_FFTR, INIT_PLANS_FFTR, &
      & FFTR_RESOL, TR, EXECUTE_PLAN_FFTR, EXECUTE_PLAN_FFTR_INPLACE

TYPE FFTR_TYPE
  !INTEGER(KIND=JPIM),POINTER :: N_PLANS(:)
  INTEGER(KIND=JPIM) :: NPLANS
  TYPE(FFTR_PLAN),POINTER :: FFTR_PLANS(:)
  INTEGER(KIND=JPIM) :: N_MAX=0
  !INTEGER(KIND=JPIM) :: N_MAX_PLANS=8
END TYPE FFTR_TYPE


TYPE FFTR_PLAN
  !INTEGER(KIND=JPIM) :: NPLAN_ID=123456
  !INTEGER(KIND=JPIM) :: NPLAN
  INTEGER(KIND=JPIM) :: NLOT
  INTEGER(KIND=JPIM) :: NTYPE
  INTEGER(KIND=JPIM) :: NISTRIDE
  INTEGER(KIND=JPIM) :: NIDIST
  INTEGER(KIND=JPIM) :: NOSTRIDE
  INTEGER(KIND=JPIM) :: NODIST
  LOGICAL :: LINPLACE
  !TYPE(FFTR_PLAN),POINTER :: NEXT_PLAN => NULL()
  TYPE(C_PTR) :: PLAN_PTR = C_NULL_PTR
END TYPE FFTR_PLAN

TYPE(FFTR_TYPE),ALLOCATABLE,TARGET :: FFTR_RESOL(:)
TYPE(FFTR_TYPE),POINTER     :: TR

! ------------------------------------------------------------------
CONTAINS
! ------------------------------------------------------------------


SUBROUTINE INIT_PLANS_FFTR(KDLON)
INTEGER(KIND=JPIM),INTENT(IN) :: KDLON

TR%N_MAX=2*KDLON   ! forward and inverse for each latitude (?)
ALLOCATE(TR%FFTR_PLANS(TR%N_MAX))
TR%NPLANS=0
RETURN

END SUBROUTINE INIT_PLANS_FFTR


SUBROUTINE CREATE_PLAN_FFTR (PLAN_PTR, KTYPE, KN, KLOT, KISTRIDE, KIDIST, KOSTRIDE, KODIST,LDINPLACE)
TYPE(C_PTR), INTENT(OUT) :: PLAN_PTR
INTEGER(KIND=JPIM),INTENT(IN)  :: KTYPE, KN, KLOT
INTEGER(KIND=JPIM), OPTIONAL, INTENT (IN) :: KISTRIDE, KIDIST
INTEGER(KIND=JPIM), OPTIONAL, INTENT (IN) :: KOSTRIDE, KODIST
LOGICAL(KIND=JPIM), OPTIONAL, INTENT(IN)  :: LDINPLACE
TYPE(FFTR_PLAN),POINTER :: CURR_FFTR_PLAN
INTEGER(KIND=JPIM) :: JL, JN
LOGICAL :: LLFOUND, LLINPLACE

INTEGER (KIND=JPIM) :: IISTRIDE, IIDIST, IOSTRIDE, IODIST, IINPLACE

INTERFACE
  SUBROUTINE CREATE_PLAN_FFTR_C (PLAN_PTR, KTYPE, KN, KLOT, KISTRIDE, KIDIST, KOSTRIDE, KODIST, KINPLACE) &
           & BIND(C,NAME="create_plan_fftr_c_")
   USE, INTRINSIC :: ISO_C_BINDING
   TYPE(C_PTR) :: PLAN_PTR
   INTEGER(C_INT) :: KTYPE, KN, KLOT, KISTRIDE, KIDIST, KOSTRIDE, KODIST, KINPLACE
  END SUBROUTINE CREATE_PLAN_FFTR_C
END INTERFACE

IISTRIDE = KLOT; IF (PRESENT (KISTRIDE)) IISTRIDE = KISTRIDE
IIDIST   =    1; IF (PRESENT (KIDIST  )) IIDIST   = KIDIST   
IOSTRIDE = KLOT; IF (PRESENT (KOSTRIDE)) IOSTRIDE = KOSTRIDE
IODIST   =    1; IF (PRESENT (KODIST  )) IODIST   = KODIST   
LLINPLACE   =  .FALSE.; IF (PRESENT (LDINPLACE  )) LLINPLACE=LDINPLACE
IINPLACE = 0; IF ( LLINPLACE ) IINPLACE = 1
LLFOUND=.FALSE.



! search for plan in existing plans
DO JL=1,TR%NPLANS
  CURR_FFTR_PLAN=>TR%FFTR_PLANS(JL)
  IF( KLOT == CURR_FFTR_PLAN%NLOT .AND. KTYPE == CURR_FFTR_PLAN%NTYPE .AND. &
    & IISTRIDE == CURR_FFTR_PLAN%NISTRIDE .AND. IIDIST == CURR_FFTR_PLAN%NIDIST .AND. &
    & IOSTRIDE == CURR_FFTR_PLAN%NOSTRIDE .AND. IODIST == CURR_FFTR_PLAN%NODIST .AND. &
	& ( LLINPLACE .EQV. CURR_FFTR_PLAN%LINPLACE ) ) THEN
    LLFOUND=.TRUE.
    PLAN_PTR=CURR_FFTR_PLAN%PLAN_PTR
    EXIT
  ENDIF
ENDDO

IF( .NOT.LLFOUND )THEN

  IF ( TR%NPLANS > TR%N_MAX ) CALL ABOR1('Maximum number of FFT plans exceeded')

  ! create new plan
  CALL CREATE_PLAN_FFTR_C(PLAN_PTR, KTYPE=KTYPE, KN=KN, KLOT=KLOT, KISTRIDE=IISTRIDE, &
                      & KIDIST=IIDIST, KOSTRIDE=IOSTRIDE, KODIST=IODIST, KINPLACE=IINPLACE )

  ! increase number of plans
  TR%NPLANS=TR%NPLANS+1
  
  ! pointer to new plan
  CURR_FFTR_PLAN=>TR%FFTR_PLANS(TR%NPLANS)

  ! store plan properties
  CURR_FFTR_PLAN%PLAN_PTR    = PLAN_PTR
  CURR_FFTR_PLAN%NLOT     = KLOT
  CURR_FFTR_PLAN%NTYPE    = KTYPE
  CURR_FFTR_PLAN%NISTRIDE = IISTRIDE
  CURR_FFTR_PLAN%NIDIST   = IIDIST
  CURR_FFTR_PLAN%NOSTRIDE = IOSTRIDE
  CURR_FFTR_PLAN%NODIST   = IODIST
  CURR_FFTR_PLAN%LINPLACE   = LLINPLACE
ENDIF

RETURN

END SUBROUTINE CREATE_PLAN_FFTR


SUBROUTINE DESTROY_PLAN_FFTR(PLAN_PTR)
TYPE(C_PTR),INTENT(IN) :: PLAN_PTR
INTERFACE
  SUBROUTINE DESTROY_PLAN_FFTR_C (PLAN_PTR) &
           & BIND(C,NAME="destroy_plan_fftr_c_")
   USE, INTRINSIC :: ISO_C_BINDING
   TYPE(C_PTR), VALUE :: PLAN_PTR
  END SUBROUTINE DESTROY_PLAN_FFTR_C
END INTERFACE
CALL DESTROY_PLAN_FFTR_C(PLAN_PTR)
RETURN
END SUBROUTINE DESTROY_PLAN_FFTR


SUBROUTINE DESTROY_ALL_PLANS_FFTR
INTEGER(KIND=JPIM) :: JL
TYPE(FFTR_PLAN),POINTER :: CURR_FFTR_PLAN
DO JL=1,TR%NPLANS
  CURR_FFTR_PLAN=>TR%FFTR_PLANS(JL)
  CALL DESTROY_PLAN_FFTR(CURR_FFTR_PLAN%PLAN_PTR)
  CURR_FFTR_PLAN%PLAN_PTR=C_NULL_PTR
ENDDO
DEALLOCATE(TR%FFTR_PLANS)
RETURN
END SUBROUTINE DESTROY_ALL_PLANS_FFTR


SUBROUTINE EXECUTE_PLAN_FFTR(PLAN_PTR,X_IN,X_OUT)
TYPE(C_PTR) :: PLAN_PTR
REAL(KIND=JPRBT) :: X_IN
REAL(KIND=JPRBT) :: X_OUT

INTERFACE
  SUBROUTINE EXECUTE_PLAN_FFTR_C (PLAN_PTR, X_IN, X_OUT) &
           & BIND(C,NAME="execute_plan_fftr_c_")
   USE, INTRINSIC :: ISO_C_BINDING
   USE PARKIND_ECTRANS, ONLY : JPRBT
   TYPE(C_PTR), VALUE :: PLAN_PTR
   REAL(KIND=JPRBT) :: X_IN, X_OUT
  END SUBROUTINE EXECUTE_PLAN_FFTR_C
END INTERFACE

!$omp target data use_device_ptr(x_in, x_out)
CALL EXECUTE_PLAN_FFTR_C(PLAN_PTR,X_IN,X_OUT)
!$omp end target data



END SUBROUTINE EXECUTE_PLAN_FFTR


SUBROUTINE EXECUTE_PLAN_FFTR_INPLACE(PLAN_PTR,X_IN)
TYPE(C_PTR) :: PLAN_PTR
REAL(KIND=JPRBT) :: X_IN

INTERFACE
  SUBROUTINE EXECUTE_PLAN_FFTR_INPLACE_C (PLAN_PTR, X_IN) &
           & BIND(C,NAME="execute_plan_fftr_inplace_c_")
   USE, INTRINSIC :: ISO_C_BINDING
   USE PARKIND_ECTRANS, ONLY : JPRBT
   TYPE(C_PTR), VALUE :: PLAN_PTR
   REAL(KIND=JPRBT) :: X_IN
  END SUBROUTINE EXECUTE_PLAN_FFTR_INPLACE_C
END INTERFACE

!$omp target data use_device_ptr(x_in)
  CALL EXECUTE_PLAN_FFTR_INPLACE_C(PLAN_PTR,X_IN)
!$omp end target data

END SUBROUTINE EXECUTE_PLAN_FFTR_INPLACE

END MODULE TPM_FFTR
